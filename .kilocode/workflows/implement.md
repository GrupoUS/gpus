---
description: Execute approved plan from /research via @apex-dev in 5 phases
---

# /implement | /implementar

## Ultra-Think Protocol

```yaml
ultra_think_protocol:
  thinking_budget: "extended"
  pre_execution_thinking:
    - "Analyze TodoWrite DAG structure and critical path"
    - "Identify parallelization opportunities by parallel_group"
    - "Anticipate edge cases in constitution compliance"
    - "Validate all preconditions are satisfiable"
  inter_atomic_thinking:
    - "Verify previous atom outputs meet postconditions"
    - "Adjust execution strategy based on actual results"
    - "Detect emergent dependencies or file conflicts"
  post_execution_thinking:
    - "Critically validate: did implementation achieve plan goals?"
    - "Assess quality metrics against acceptance criteria"
    - "Identify technical debt or gaps introduced"
```

Execute the approved implementation plan from TodoWrite.

## Trigger

- User approves research plan: "aprovar plano", "approve", "proceed"
- Direct command: `/implement`

---

## Input Contract

Required inputs for a correct `/implement` run:

```yaml
input_contract:
  source: "TodoWrite state created by /research command"
  expected_task_format:
    id: "AT-XXX or VT-XXX"
    content: "[ID] Title | Phase: N | Files: paths"
    status: "pending"
    priority: "high | medium | low"
  required_metadata_in_content:
    - phase: "Extracted from 'Phase: N'"
    - files_affected: "Extracted from 'Files: path1, path2'"
    - parallel_group: "Extracted from parallel group marker (optional)"
  dependencies:
    source: "Inferred from task order and research report"
    format: "Array of task IDs"
  validation:
    - "All AT-XXX tasks have phase 1-5"
    - "All VT-XXX tasks are at the end"
    - "Subtasks (AT-XXX-A) immediately follow parent"
  compatibility_note: |
    This format is generated by @apex-researcher via todowrite()
    as specified in .opencode/command/research.md Step 3.
```

If any required input is missing, `/implement` MUST stop and request remediation.

---

## Optimized Architecture

```mermaid
flowchart LR
  A[Plan Mode: /research] --> B[TodoWrite: AT-* + VT-*]
  B --> C[Act Mode: /implement]

  C --> D[@apex-dev: task runner]
  D --> E{Delegation?}
  E -->|convex/*| F[@database-specialist]
  E -->|src/components/*| G[@apex-ui-ux-designer]
  E -->|security/compliance| H[@code-reviewer]
  E -->|default| D

  D --> I[Phase checkpoints\n(lint/build/test)]
  I --> J[Completion report]
```

---

## Step 1: Load TodoWrite Tasks

Parse TodoWrite tasks created by `/research`:

### Execution Mode

Mode: `one_shot_proactive`

> This mode is optimized for approved, deterministic execution. If required inputs or constitution checks fail, stop early and request remediation.

```yaml
todowrite_parsing:
  source: "TodoWrite state from /research"

  extract_fields:
    - id: "AT-XXX or VT-XXX"
    - content: "Task description with metadata"
    - status: "pending | in_progress | completed | failed"
    - priority: "high | medium | low"

  parse_metadata:
    # Expected format (created by /research via apex-researcher):
    # "[AT-001] Title | Phase: 3 | Files: src/x.ts" + optional fields
    # Subtasks are written as: "  ↳ [AT-001-A] Subtask description"
    from_content: "[ID] Title | Phase: N | Files: paths"
    extract:
      - phase: "[1-5] from Phase: N"
      - parallel_group: "[A|B|C|null] when present"
      - files_affected: "Array of file paths (from Files: ...)"
      - dependencies: "Array of task IDs this depends on (when present)"
      - test_strategy: "unit | integration | e2e | none (when present)"
      - rollback_strategy: "How to undo (when present)"
```

---

## Step 2: Order and Group Tasks

Apply **Ultra-Think Protocol (UTP)** here to avoid unnecessary work and to ensure safe ordering.

### Phase-Based Ordering

Group tasks by phase (1→5) and resolve dependencies:

```yaml
phase_ordering:
  algorithm:
    1. Group tasks by phase: [1, 2, 3, 4, 5]
    2. Within phase, topological sort by dependencies
    3. Tasks with no dependencies can start immediately
    4. Tasks with dependencies wait for dependency completion

  phases:
    phase_1_setup:
      checkpoint: "bun install && bun run build"
      activities: ["directories", "dependencies", "config", "schema"]

    phase_2_test:
      checkpoint: "bun run test --run"
      activities: ["unit tests", "fixtures", "mocks"]

    phase_3_core:
      checkpoint: "bun run build && bun run lint:check && bun run test"
      activities: ["queries", "mutations", "hooks", "components"]

    phase_4_integration:
      checkpoint: "bun run build && bun run lint:check && bun run test"
      activities: ["routes", "auth guards", "middleware"]

    phase_5_polish:
      checkpoint: "bun run build && bun run lint:check && bun run test:coverage"
      activities: ["optimization", "cleanup", "docs", "accessibility"]
```

### Parallel Group Batching (`parallel_tool_calling`) + Decision Table

Safe parallelization is optional and MUST follow UTP + constitution constraints.

**Strategy**: `parallel_tool_calling`
- Only parallelize tasks that are *provably independent*.
- Default to sequential if there is any uncertainty.

**Hard limits** (to reduce risk):
- Max parallel tasks per batch: **3**
- Never parallelize if *any* task in the batch touches:
  - auth/security/LGPD surfaces
  - schema/config files (e.g., `convex/schema.ts`, `vite.config.ts`)
  - generated files

**Rules**:
- Tasks with the same `parallel_group` MAY run concurrently.
- Tasks in the same parallel group MUST NOT modify the same files.
- `parallel_group = null` is always sequential.
- Dependencies always override parallelization.
- If compliance/security is triggered, force sequential + require `@code-reviewer` before completion.

**Decision table**:

| Condition | Example | Can run in parallel? | Notes |
|---|---|---:|---|
| Same `parallel_group` AND no shared files AND no unmet dependencies | AT-003 + AT-004 both group A, distinct files | Yes | Preferred case |
| Same `parallel_group` BUT shared files | both touch `convex/schema.ts` | No | Force sequential |
| Different `parallel_group` | group A vs B | Only if phases/deps allow | Default: keep sequential |
| Any unmet dependency | AT-005 depends on AT-004 | No | Wait for dependency |
| Any constitution gate uncertain (security/auth/LGPD) | auth changes | No | Run sequential + require review |

```yaml
parallel_batching:
  strategy: "parallel_tool_calling"
  max_parallel: 3

  constraints:
    - "Same parallel_group only"
    - "No shared files_affected"
    - "All dependencies completed"

  on_conflict:
    action: "Fallback to sequential"
    log: "Warn: file conflict detected in parallel batch"

  on_dependency_block:
    action: "Wait until dependencies complete"

  example:
    batch_A:  # Concurrent execution
      - AT-002: "Write notification mutation tests"
      - AT-003: "Write notification UI tests"

    sequential:  # One at a time
      - AT-004: "Implement sendNotification mutation"
```

---

### 3. Task Execution Flow

For each task:

```yaml
task_execution:
  1_mark_in_progress:
    action: "Update TodoWrite status to 'in_progress'"

  2_check_dependencies:
    action: "Verify all dependency tasks are 'completed'"
    on_blocked: "Wait for dependencies"

  3_delegate_or_execute:
    action: "Route to appropriate agent based on files_affected"
    pass_context:
      - "constitution.md"
      - "spec.md (if available)"
      - "Task details and acceptance criteria"

  4_implement:
    action: "Execute task implementation"
    guidelines:
      - "Follow constitution principles"
      - "Match spec contracts (if available)"
      - "Meet acceptance criteria"

  5_validate:
    action: "Run acceptance criteria checks"
    on_pass: "Mark 'completed'"
    on_fail: "Execute rollback, mark 'failed'"
```

### 4 Postconditions (Validation + Commands + Sequence Diagram)

Each task MUST end in a validated postcondition.

```yaml
4_validate_postconditions:
  after_each_task:
    verify:
      - acceptance_criteria_met: "All criteria from task definition pass"
      - files_created_modified: "Expected files exist with correct content"
      - no_regressions: "Existing tests still pass"
      - constitution_compliant: "Implementation follows all 10 principles"
    validation_commands:
      - "bun run build"
      - "bun run lint:check"
      - "bun run test --run"
    on_failure:
      action: "Execute rollback_strategy immediately"
      mark_status: "failed"
      halt_phase: true
      report:
        - task_id: "[AT-XXX]"
        - failed_postcondition: "[description]"
        - rollback_executed: "[command]"
        - current_state: "[after rollback]"
```

**Validation commands (task-level)**:
- `bun run lint:check` (Biome)
- `bun run build` (TypeScript + build)
- `bun run test --run` (Vitest)

> Note: you may scope validations during development for speed, but **a phase checkpoint MUST run the full required commands**.

```mermaid
sequenceDiagram
  autonumber
  participant R as /implement runner
  participant TD as TodoWrite
  participant AD as @apex-dev
  participant DS as @database-specialist
  participant UX as @apex-ui-ux-designer
  participant CR as @code-reviewer
  participant V as Validation (lint/build/test)

  R->>TD: Read pending tasks
  R->>AD: Start next task (UTP applied)
  AD->>TD: Mark in_progress

  alt Delegation needed
    AD->>DS: Implement Convex task
    DS-->>AD: Changes ready
  else UI task
    AD->>UX: Implement UI task
    UX-->>AD: Changes ready
  else Security/compliance validation
    AD->>CR: Review (read-only)
    CR-->>AD: Findings / approval
  end

  AD->>V: Run validations (phase/task scoped)
  alt Validation PASS
    AD->>TD: Mark completed
  else Validation FAIL
    AD->>AD: Execute rollback strategy
    AD->>TD: Mark failed + log reason
  end
```

---
